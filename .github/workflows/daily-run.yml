name: Daily News & Reports Run

on:
  schedule:
    - cron: '0 5 * * *'
    - cron: '0 4 * * *'
  workflow_dispatch:
    inputs:
      mode:
        description: 'Mode für die Lauf (overwrite oder skip)'
        required: true
        default: 'overwrite'
        type: choice
        options:
          - overwrite
          - skip
      locale:
        description: 'Locale für die GitHub-Aufrufe (de|en|both)'
        required: true
        default: 'both'
        type: choice
        options:
          - de
          - en
          - both
      dryRun:
        description: 'Nur testen ohne eigentliche Persistenz'
        required: true
        default: 'no'
        type: choice
        options:
          - yes
          - no

jobs:
  run-daily:
    runs-on: ubuntu-latest
    outputs:
      dailyJson: ${{ steps.call-daily.outputs.dailyJson }}
    steps:
      - id: call-daily
        name: Call combined daily-run endpoint
        env:
          TARGET_URL: ${{ secrets.TARGET_URL }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          MODE: ${{ github.event.inputs.mode || 'overwrite' }}
          LOCALE_INPUT: ${{ github.event.inputs.locale || 'both' }}
          DRY_RUN: ${{ github.event.inputs.dryRun || 'no' }}
        run: |
          node <<'NODE'
          (async () => {
            const fs = require('fs');
            const {env, exit} = process;
            const TARGET_URL = env.TARGET_URL;
            const CRON_SECRET = env.CRON_SECRET;
            const MODE = env.MODE;
            const LOCALE_INPUT = env.LOCALE_INPUT;
            const DRY_RUN = env.DRY_RUN;
            const githubOutput = env.GITHUB_OUTPUT;
            if (!TARGET_URL || !CRON_SECRET) {
              console.error('Missing TARGET_URL or CRON_SECRET');
              exit(1);
            }
            const retries = [
              {delay: 0, label: 'initial'},
              {delay: 15000, label: 'retry1'},
              {delay: 30000, label: 'retry2'},
              {delay: 60000, label: 'retry3'},
            ];
            const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
            async function call() {
              const url = new URL(TARGET_URL);
              const headers = {'x-cron-secret': CRON_SECRET};
              url.searchParams.set('mode', MODE);
              if (LOCALE_INPUT && LOCALE_INPUT !== 'both') {
                url.searchParams.set('locale', LOCALE_INPUT);
              }
              url.searchParams.set('dryRun', DRY_RUN);
              const response = await fetch(url, {method: 'GET', headers});
              const text = await response.text();
              let payload;
              try {
                payload = JSON.parse(text);
              } catch {
                throw new Error(`Invalid JSON response (status ${response.status})`);
              }
              return {response, payload};
            }
            let lastError = null;
            for (const attempt of retries) {
              if (attempt.delay && attempt.delay > 0) {
                console.log(`Waiting ${attempt.delay}ms before ${attempt.label}`);
                await wait(attempt.delay);
              }
              try {
                const {response, payload} = await call();
                const is5xx = response.status >= 500;
                const okFlag = payload?.news?.ok ?? payload?.ok ?? false;
                const partial = payload?.partial ?? okFlag === false;
                const summary = {
                  status: response.status,
                  partial,
                  durationMs: payload?.durationMs ?? null,
                  items: payload?.news?.items ?? null,
                  assets: payload?.reports?.assets ?? null,
                  inputs: {mode: MODE, locale: LOCALE_INPUT, dryRun: DRY_RUN},
                };
                console.info('daily-run summary', summary);
                if (githubOutput) {
                  fs.appendFileSync(githubOutput, `dailyJson=${JSON.stringify(payload)}\n`);
                }
                if (is5xx || (!okFlag && partial === false)) {
                  throw new Error(`Unsuccessful run: ${JSON.stringify(summary)}`);
                }
                if (partial) {
                  console.warn('Partial result detected, job marked success with warning.');
                }
                return;
              } catch (error) {
                lastError = error;
                console.warn(`Attempt ${attempt.label} failed`, error.message ?? error);
                continue;
              }
            }
            console.error('All retries exhausted');
            if (lastError) console.error(lastError);
            exit(1);
          })().catch((err) => {
            console.error('Workflow script fatal:', err);
            process.exit(1);
          });
          NODE
  health-check:
    needs: run-daily
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate daily-run output via /api/health
        env:
          DAILY_JSON: ${{ needs.run-daily.outputs.dailyJson }}
          HEALTH_URL: ${{ secrets.HEALTH_URL }}
          TARGET_URL: ${{ secrets.TARGET_URL }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
        run: |
          node <<'NODE'
          const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
          async function evaluatePayload(payload, label) {
            const newsItems = payload?.news?.items ?? 0;
            const assets = payload?.reports?.assets ?? 0;
            const partial = payload?.partial ?? false;
            console.info(`${label} health summary`, { newsItems, assets, partial });
            if (newsItems > 0 && assets > 0) {
              return true;
            }
            if (partial) {
              console.warn(`${label} is partial but non-blocking`);
              return true;
            }
            return false;
          }
          (async () => {
            const {env} = process;
            const waitTime = 75_000;
            console.info(`Waiting ${waitTime}ms for deployment propagation`);
            await delay(waitTime);
            const targetHealth = env.HEALTH_URL || env.TARGET_URL?.replace(/\/api\/generate\/.*$/, '/api/health');
            const headers = env.CRON_SECRET ? { 'x-cron-secret': env.CRON_SECRET } : {};
            let healthPayload = null;
            if (targetHealth) {
              try {
                const response = await fetch(targetHealth, { method: 'GET', headers });
                if (response.ok) {
                  healthPayload = await response.json();
                  const ok = await evaluatePayload({
                    news: { items: healthPayload?.news?.newsItemsCount ?? 0 },
                    reports: { assets: healthPayload?.reports?.assetsCount ?? 0 },
                    partial: healthPayload?.partial,
                  }, 'remote');
                  if (ok) {
                    return;
                  }
                } else {
                  console.warn(`Health endpoint returned ${response.status}`);
                }
              } catch (error) {
                console.warn('Health fetch failed', error);
              }
            } else {
              console.warn('No health URL configured, skipping remote check');
            }
            const raw = env.DAILY_JSON;
            if (raw) {
              try {
                const payload = JSON.parse(raw);
                const ok = await evaluatePayload(payload, 'dailyJson');
                if (ok) {
                  return;
                }
              } catch (error) {
                console.warn('dailyJson parse failed', error);
              }
            } else {
              console.warn('No dailyJson output available for fallback');
            }
            throw new Error('Health validation failed: insufficient data');
          })().catch((error) => {
            console.error('Health check fatal:', error);
            process.exit(1);
          });
          NODE
  snapshot-dump:
    needs: [run-daily, health-check]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Install Node dependencies
        run: npm ci
      - name: Dump snapshots and commit
        env:
          TARGET_URL: ${{ secrets.TARGET_URL }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          REDIS_URL: ${{ secrets.KV_URL || secrets.REDIS_URL }}
          REDIS_TOKEN: ${{ secrets.REDIS_TOKEN }}
        run: |
          node <<'NODE'
          const {env, exit} = process;
          const TARGET_URL = env.TARGET_URL;
          const CRON_SECRET = env.CRON_SECRET;
          const REDIS_URL = env.REDIS_URL;
          const REDIS_TOKEN = env.REDIS_TOKEN;
          if (!TARGET_URL || !CRON_SECRET || !REDIS_URL) {
            console.error('Missing TARGET_URL, CRON_SECRET or REDIS_URL');
            exit(1);
          }
          const Redis = require('ioredis');
          const redis = new Redis(REDIS_URL, REDIS_TOKEN ? { username: 'default', password: REDIS_TOKEN } : {});
          const url = new URL(TARGET_URL);
          url.searchParams.set('mode', 'dump');
          url.searchParams.set('locale', 'both');
          const headers = {'x-cron-secret': CRON_SECRET};
          const redisKey = (prefix, locale, date) => `${prefix}:${locale}:${date}`;
          (async () => {
            const response = await fetch(url, {method: 'GET', headers});
            const payload = await response.json();
            if (!payload?.date || !payload?.news?.report || !payload?.reports?.report) {
              throw new Error('Invalid payload, missing report data');
            }
            const date = payload.date;
            const newsDeKey = redisKey('news', 'de', date);
            await redis.set(newsDeKey, JSON.stringify({...payload.news.report, locale: 'de'}));
            console.info('Redis set', newsDeKey);
            const newsEnKey = redisKey('news', 'en', date);
            await redis.set(newsEnKey, JSON.stringify({...payload.news.report, locale: 'en'}));
            console.info('Redis set', newsEnKey);
            const reportsDeKey = redisKey('reports', 'de', date);
            await redis.set(reportsDeKey, JSON.stringify({...payload.reports.report, locale: 'de'}));
            console.info('Redis set', reportsDeKey);
            const reportsEnKey = redisKey('reports', 'en', date);
            await redis.set(reportsEnKey, JSON.stringify({...payload.reports.report, locale: 'en'}));
            console.info('Redis set', reportsEnKey);
            const metricsKey = `metrics:${date}`;
            await redis.set(metricsKey, JSON.stringify(payload.metrics ?? { date }));
            console.info('Redis set', metricsKey);
            await redis.zadd(`news:dates:de`, Date.parse(date) || 0, date);
            await redis.zadd(`news:dates:en`, Date.parse(date) || 0, date);
            console.info('Snapshot dump stored in Redis for', date);
            redis.disconnect();
          })().catch((err) => {
            console.error('Snapshot dump failed:', err);
            redis.disconnect();
            process.exit(1);
          });
          NODE
